- Differentiate between Environment Variables and Shell Variables
  - **Environment Variables:** System-wide variables built into the system that control how it looks, acts, and feels. They are inherited by any child shells or processes.
  - **Shell Variables:** Typically listed in lowercase and are only valid in the shell they are set in.

- What is the name of the environment in Kali Linux?
  - bash shell

- Describe the syntax structure used for defining variables
  - **Basic Pair:** `KEY=value` (Strings in key-value pairs).
  - **Multiple Values:** `KEY=value1:value2` (Values separated by a colon).
  - **Spaces:** If a value contains spaces, it must be enclosed in quotation marks.

- What are the main reasons for modifying default environment variables in a Linux hacking system?
  - To maximize system efficiency (performance).
  - To tailor the work environment to meet individual needs (convenience).
  - To cover tracks and avoid leaving evidence (stealth).
  
- View all default environment variables on the system
  ```bash
    env
  ```
- Overview of the following variables 
  - **TERM:** Specifies the terminal type (e.g., `xterm`).
  - **SHELL:** The path to the current shell (e.g., `/bin/bash`).
  - **USER:** The current logged-in user (e.g., `root`).
  - **PATH:** A list of directories the system searches for executable programs.
  - **HOME:** The home directory of the current user (e.g., `/root`).

- What is the naming convention for environment variables?
  - Environment variables are always uppercase, such as `HOME`, `PATH`, and `SHELL`.

- View all environment variables, including shell variables, local variables, and shell functions
  ```bash
    set
  ```
  - This command lists all environment variables unique to your system, including user-defined variables and command aliases.

- View environment variables line by line and the interactive buttons
  ```bash
    set | more
  ```
  - **ENTER:** Press to advance the terminal to the next line/variable.
  - **q:** Press to quit (exit) the view and return to the command prompt.

- Filter for a specific variable (e.g., `HISTSIZE`) within the environment list
  ```bash
    set | grep HISTSIZE
  ```
- What does `HISTSIZE` define and what is the default value
  - **HISTSIZE:** Specifies the maximum number of commands the command history file will store. It does not store the commands themselves, just the limit.
  - **1000:** The default value indicating that the terminal will store the last 1,000 commands, which can be recalled using the up and down arrow keys.
- Change the value of `HISTSIZE` to disable command history storage for the current session
  ```bash
    HISTSIZE=0
  ```
  - **Result:** Setting this variable to `0` prevents the system from storing past commands.
  - **Effect:** The up and down arrow keys will no longer recall previous commands.
  - **Purpose:** This technique is useful for stealth to avoid leaving evidence of activity on a system.

- Which command is used to turn a local shell variable into an environment variable, making it available to all child processes and sub-sessions?
  ```bash
    export
  ```
- Which command is used to share the current shell's HISTSIZE variable with child processes and sub-sessions?
  ```bash
    export HISTSIZE
  ```
- Save the current value of the `HISTSIZE` variable to a text file named `valueofHISTSIZE.txt` in the home directory
  ```bash
    echo $HISTSIZE > ~/valueofHISTSIZE.txt
  ```
  - **Purpose:** Variables are strings, so it is a safety precaution to save the contents of a variable to a text file before modifying it, allowing you to undo changes later.

- Save the output of all current environment settings to a text file named `valueofALLon01012017.txt` in the home directory
  ```bash
    set > ~/valueofALLon01012017.txt
  ```
  - **Purpose:** This creates a text file containing all current settings for a more comprehensive backup.

- How do you update the HISTSIZE variable to 1000 and ensure it is available as an environment variable for child processes and sub-shells?
  ```bash
    HISTSIZE=1000
    export HISTSIZE
  ```

- Which command is used to display the path of the current shell environment you are using?
  ```bash
    echo $SHELL
  ```

- Persistently disable command history by modifying the configuration file, and make the changes permanent.
  1. Identify the shell: echo $SHELL (determines if you should edit .zshrc or .bashrc).
  2. Edit the configuration: nano ~/.zshrc (add or change HISTSIZE=0).
  3. Apply the changes: source ~/.zshrc (reloads the config without restarting the terminal).
  4. Verify the update: echo $HISTSIZE (confirms the value is now 0).

- What does `PS1` variable do?
  - **PS1:** The environment variable that controls the shell prompt format.
  - **Session Behavior:** Without the `export` command, the custom prompt will only exist for the current terminal session.
  - 
- What do the following placeholders represent when used in the `PS1` variable?
  - **\u:** The name of the current user.
  - **\h:** The hostname.
  - **\W:** The base name of the current working directory.

- Set the shell prompt variable to the string `"World's Best Hacker: #"` and export it to make it permanent across sessions
  ```bash
    PS1="World's Best Hacker: #"
    export PS1
  ```

- Configure the shell prompt to mimic a Windows command prompt using `C:` and the current directory.
  ```bash
    export PS1='C:\w> '
  ```
  - **Result:** The prompt will display as `C:/tmp>` (assuming `/tmp` is the current directory)

- Where most of the executable commands are located?
  - Most commands are located in the `sbin` or `bin` subdirectory

- Syntax for viewing a particular variable.
    ```bash
      echo $PATH
    ```

- What does `PATH` variable do?
  - Controls the list of directories the system searches for executable programs for instance, `cd`, `ls` and `echo`.

- View the directories of executatble programs currently stored
  ```bash
    echo $PATH
  ```

- How multiple directory paths are placed?
  - Each directory path is separated by a colon (`:`).

- Why might the shell return a `command not found` error even if the command exists on the system?
  - The shell searches for commands only within the directories listed in the `PATH` variable. If the command's directory is not included in the `PATH`, the shell cannot find or execute it automatically.

- Append the directory `/root/newhackingtool` to the current `PATH` variable to allow running its tools from any location
  ```bash
    PATH=$PATH:/root/newhackingtool
  ```
  - **Mechanism:** This assigns the original `PATH` content (`$PATH`) plus the new directory (separated by a colon) back to the `PATH` variable.
  - **Benefit:** You can execute `newhackingtool` applications from anywhere on the system without needing to navigate to the `/root/newhackingtool` directory first.

- Verify that the `/root/newhackingtool` directory has been successfully added to the `PATH`
  ```bash
    echo $PATH
  ```
  - **Result:** The output should list the original directories followed by `:/root/newhackingtool` at the end.

- Why should you avoid adding too many directories to the `PATH` variable?
  - **Performance Impact:** The system searches through every directory listed in the `PATH` to locate commands. Adding a large number of directories can slow down the terminal and command execution.

- Demonstrate the incorrect command to assign `/root/newhackingtool` to the `PATH` variable and explain why this leads to a "command not found" error for standard system commands
  ```bash
    PATH=/root/newhackingtool
  ```
  - **The Error:** This command *replaces* the existing `PATH` entirely with just the new directory, rather than *appending* to it.
  - **Consequence:** Critical system binary directories (like `/bin` and `/sbin`) are removed from the search path.
  - **Result:** The shell cannot locate standard commands (like `clear` or `ls`), causing them to fail unless you navigate directly to their physical location.

- What precaution should be taken before modifying the `PATH` variable to prevent accidental data loss?
  - Save the current contents of the variable to a secure location (e.g., a text file) before making changes.

- Create a user-defined variable named `MYNEWVARIABLE` containing the string `"Hacking is the most valuable skill set in the 21st century"`
  ```bash
    MYNEWVARIABLE="Hacking is the most valuable skill set in the 21st century"
  ```
  - **Purpose:** User-defined variables are useful for shell scripting or storing long commands to avoid repetitive typing.
  - **Note:** Just like system variables, user-defined variables must be exported to persist to new sessions.

- Display the value stored in the `MYNEWVARIABLE` variable
  ```bash
    echo $MYNEWVARIABLE
  ```

- Delete the `MYNEWVARIABLE` variable from the session
  ```bash
    unset MYNEWVARIABLE
  ```
  - **Caution:** Always think carefully before deleting a system variable, as the system may operate differently afterward.

- Verify that `MYNEWVARIABLE` has been successfully deleted
  ```bash
    echo $MYNEWVARIABLE
  ```
  - **Result:** Linux returns a blank line, indicating the variable and its value no longer exist.

- Again Create the `MYNEWVARIABLE` variable and this time make it permanent meaning surviving session close, startup.
  - Open `~/.zshrc` 
  - Add `export MYNEWVARIABLE="Hacking is the most valuable skill set in the 21st century"` and save the file.
  - Reload the terminal `source ~/.zshrc`
  - Check using `echo $MYNEWVARIABLE`.

- Delete the newly added variable
  - Go to the config file, delete, save and reload terminal.